esphome:
  name: esp32-diesel-heater
  friendly_name: ESP32 Diesel Heater

esp32:
  board: esp32dev
  framework:
    type: arduino

logger:

api:
  encryption:
    key: "vHF/emJMoAZz3q8k4JySuSZnYEa43IujpwN9+fQkwYk="

ota:
  platform: esphome
  password: "09ec3c09b5847b5a4eeef2c15ce8fb00"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  ap:
    ssid: "ESP32 Diesel Heater"
    password: "12345678"

######################################################################################################
# If you wat to use this integration in existing ESPHome device, just copy/adapt the following part. #
######################################################################################################

substitutions:
  heater_mac: EC:B1:D6:00:92:87 # change to your diesel heater MAC address
  ble_service_uuid: 0000fff0-0000-1000-8000-00805f9b34fb
  ble_characteristic_uuid: 0000fff1-0000-1000-8000-00805f9b34fb

esp32_ble_tracker:

ble_client:
  - mac_address: ${heater_mac}
    id: heater_ble

globals:
  - id: defer_communication
    type: int
    restore_value: no
    initial_value: '0'
  - id: last_received_level
    type: float
    restore_value: no
    initial_value: '0'
  - id: last_set_level
    type: float
    restore_value: no
    initial_value: '0'

interval:
  - interval: 15s
    then:
      - ble_client.connect: heater_ble
      - if:
          condition: 
            lambda: 'return id(defer_communication) < 1;'
          then:
            - script.execute: heater_ping

text_sensor:
  - platform: template
    name: "Heater Status"
    id: heater_status
    icon: "mdi:hvac"

sensor:
  - platform: template
    name: "Battery Voltage"
    id: battery_voltage
    unit_of_measurement: "V"
    accuracy_decimals: 0 # heater reports voltage without decimal places
    device_class: voltage
    icon: "mdi:car-battery"

  - platform: template
    name: "Output Temperature"
    id: output_temperature
    unit_of_measurement: "Â°C"
    accuracy_decimals: 0
    icon: "mdi:thermometer"

  - platform: ble_client
    type: characteristic
    id: my_ble_sensor
    ble_client_id: heater_ble
    service_uuid: ${ble_service_uuid}
    characteristic_uuid: ${ble_characteristic_uuid}
    name: "BLE Raw Data"
    internal: True
    notify: True
    lambda: |-
      ESP_LOGD("BLE", "Received data: %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X",
                  x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10], x[11], x[12], x[13], x[14], x[15], x[16], x[17], x[18], x[19], x[20]);
      //                                status       level            voltage       ????        out.temp.                                         checksum
      //  sample: ab    ba    11    cc    01    00    06    05    00    0d    00     39     00     ba     00     00     00     00     00     00     4e

      if (id(defer_communication)) {
        return 0;
      }

      static const char* const states[] = {"Standby", "Heating", "Cooldown", "-unused-", "Fan"};
      if (x[4] < sizeof(states)/sizeof(states[0])) {
        id(heater_status).publish_state(states[x[4]]);
      } else {
        ESP_LOGD("Error", "Received state does not match known possible states: %02d", x[4]);
      }

      if (states[x[4]] == "Fan") {
        id(fan_level).publish_state(x[6]);
        id(heater_level).publish_state(0);
      }
      if (states[x[4]] == "Heating") {
        id(heater_level).publish_state(x[6]);
        id(fan_level).publish_state(0);
      }

      id(last_received_level) = x[6];
      id(battery_voltage).publish_state(x[9]);
      id(output_temperature).publish_state((int16_t)x[13]);
      return 0;

number:
  - platform: template
    name: "Fan"
    id: fan_level
    min_value: 0
    max_value: 6
    step: 1
    icon: "mdi:fan"
    optimistic: True
    set_action:
      then:
        - script.execute:
            id: heater_onchange
            mode: "Fan"
            level: !lambda 'return x;'

  - platform: template
    name: "Heating"
    id: heater_level
    min_value: 0
    max_value: 6
    step: 1
    icon: "mdi:radiator"
    optimistic: True
    set_action:
      then:
        - script.execute:
            id: heater_onchange
            mode: "Heating"
            level: !lambda 'return x;'

script:
  - id: heater_ping
    then:
      - logger.log: "sending: heater ping"
      - ble_client.ble_write:
          service_uuid: ${ble_service_uuid}
          characteristic_uuid: ${ble_characteristic_uuid}
          value: [0xba, 0xab, 0x04, 0xcc, 0x00, 0x00, 0x00, 0x35]

  - id: heater_fan_toggle
    then:
      - ble_client.ble_write:
          service_uuid: ${ble_service_uuid}
          characteristic_uuid: ${ble_characteristic_uuid}
          value: [0xba, 0xab, 0x04, 0xbb, 0xa4, 0x00, 0x00, 0xc8]

  - id: heater_heating_toggle
    then:
      - ble_client.ble_write:
          service_uuid: ${ble_service_uuid}
          characteristic_uuid: ${ble_characteristic_uuid}
          value: [0xba, 0xab, 0x04, 0xbb, 0xa1, 0x00, 0x00, 0xc5]

  - id: heater_level_up
    then:
      - ble_client.ble_write:
          service_uuid: ${ble_service_uuid}
          characteristic_uuid: ${ble_characteristic_uuid}
          value: [0xba, 0xab, 0x04, 0xbb, 0xa2, 0x00, 0x00, 0xc6]

  - id: heater_level_down
    then:
      - ble_client.ble_write:
          service_uuid: ${ble_service_uuid}
          characteristic_uuid: ${ble_characteristic_uuid}
          value: [0xba, 0xab, 0x04, 0xbb, 0xa3, 0x00, 0x00, 0xc7]

  - id: heater_onchange
    parameters: 
      mode: string
      level: float
    then:
      - ble_client.connect: heater_ble
      - if:
          condition:
            lambda: 'return !id(defer_communication) && (id(heater_status).state == "Standby" || id(heater_status).state == mode);'
          then:
            - globals.set:
                id: defer_communication
                value: '1' 
            - globals.set:
                id: last_set_level
                value: !lambda 'return level;' 
            - if: 
                condition:
                  lambda: 'return level > 0 && id(heater_status).state == "Standby";'
                then:
                  - logger.log: "sending: heater turn ON"
                  - lambda: |-
                      if (mode == "Fan") {
                        id(heater_fan_toggle)->execute();
                      } else {
                        id(heater_heating_toggle)->execute();
                      }
                  - globals.set:
                      id: last_received_level
                      value: '3' # at the start level is always set to 3 by the heater
                  - delay: 0.7s
                else: 
                  if:
                    condition: 
                      lambda: 'return level == 0;'
                    then:
                      - logger.log: "sending: heater turn OFF"
                      - lambda: |-
                          if (mode == "Fan") {
                            id(heater_fan_toggle)->execute();
                          } else {
                            id(heater_heating_toggle)->execute();
                          }
                      - delay: 0.7s
            - if: 
                condition:
                  lambda: 'return level != 0;'
                then:
                  repeat:
                    count: !lambda 'return fabs(level - id(last_received_level));'
                    then:
                      - delay: 0.4s
                      - if:
                          condition:
                            lambda: 'return level < id(last_received_level);'
                          then:
                            - logger.log: "sending: heater level decrease"
                            - script.execute: heater_level_down
                          else:
                            - logger.log: "sending: heater level increase"
                            - script.execute: heater_level_up
            - delay: 0.8s
            - globals.set:
                id: defer_communication
                value: '0'
          else:
            - delay: 0.1s
            - lambda: |-
                if (id(heater_status).state == mode || id(heater_status).state == "Standby") {
                  if (mode == "Fan") {
                    id(fan_level).publish_state(id(last_set_level));
                  } else {
                    id(heater_level).publish_state(id(last_set_level));
                  }
                } else {
                  if (mode == "Fan") {
                    id(fan_level).publish_state(0);
                  } else {
                    id(heater_level).publish_state(0);
                  }
                }
      - script.execute: heater_ping

